h2. Action View Overview

In this guide you will learn:

* What Action View is, and how to use it with Rails
* How to use Action View outside of Rails
* How best to use templates, partials, and layouts
* What helpers are provided by Action View, and how to make your own
* How to use localized views

endprologue.

h3. What is Action View?

Action View and Action Controller are the two major components of Action Pack. In Rails, web requests are handled by Action Pack, which splits the work into a controller part (performing the logic) and a view part (rendering a template). Typically, Action Controller will be concerned with communicating with the database and performing CRUD actions where necessary. Action View is then responsible for compiling the response.

Action View templates are written using embedded Ruby in tags mingled with HTML. To avoid cluttering the templates with boilerplate code, a number of helper classes provide common behavior for forms, dates, and strings. It's also easy to add new helpers to your application as it evolves.

NOTE. Some features of Action View are tied to Active Record, but that doesn't mean that Action View depends on Active Record. Action View is an independent package that can be used with any sort of backend.

h3. Using Action View with Rails

For each controller there is an associated directory in the <tt>app/views</tt> directory which holds the template files that make up the views associated with that controller. These files are used to display the view that results from each controller action.

Let's take a look at what Rails does by default when creating a new resource using the scaffold generator:

<shell>
$ rails generate scaffold post
      [...]
      invoke  scaffold_controller
      create    app/controllers/posts_controller.rb
      invoke    erb
      create      app/views/posts
      create      app/views/posts/index.html.erb
      create      app/views/posts/edit.html.erb
      create      app/views/posts/show.html.erb
      create      app/views/posts/new.html.erb
      create      app/views/posts/_form.html.erb
      [...]
</shell>

There is a naming convention for views in Rails. Typically, the views share their name with the associated controller action, as you can see above.
For example, the index controller action of the <tt>posts_controller.rb</tt> will use the <tt>index.html.erb</tt> view file in the <tt>app/views/posts</tt> directory.
The complete HTML returned to the client is composed of a combination of this ERB file, a layout template that wraps it, and all the partials that the view may reference. Later on this guide you can find a more detailed documentation of each one of this three components.

h3. Using Action View outside of Rails

Action View works well with Action Record, but it can also be used with other Ruby tools. We can demonstrate this by creating a small "Rack":http://rack.rubyforge.org/ application that includes Action View functionality. This may be useful, for example, if you'd like access to Action View's helpers in a Rack application.

Let's start by ensuring that you have the Action Pack and Rack gems installed:

<shell>
$ gem install actionpack
$ gem install rack
</shell>

Now we'll create a simple "Hello World" application that uses the +titleize+ method provided by Active Support.

*hello_world.rb:*

<ruby>
require 'rubygems'
require 'active_support/core_ext/string/inflections'
require 'rack'

def hello_world(env)
  [200, {"Content-Type" => "text/html"}, "hello world".titleize]
end

Rack::Handler::Mongrel.run method(:hello_world), :Port => 4567
</ruby>

We can see this all come together by starting up the application and then visiting +http://localhost:4567/+

<shell>
$ ruby hello_world.rb
</shell>

TODO needs a screenshot? I have one - not sure where to put it.

Notice how 'hello world' has been converted into 'Hello World' by the +titleize+ helper method.

Action View can also be used with "Sinatra":http://www.sinatrarb.com/ in the same way.

Let's start by ensuring that you have the Action Pack and Sinatra gems installed:

<shell>
$ gem install actionpack
$ gem install sinatra
</shell>

Now we'll create the same "Hello World" application in Sinatra.

*hello_world.rb:*

<ruby>
require 'rubygems'
require 'action_view'
require 'sinatra'

get '/' do
  erb 'hello world'.titleize
end
</ruby>

Then, we can run the application:

<shell>
$ ruby hello_world.rb
</shell>

Once the application is running, you can see Sinatra and Action View working together by visiting +http://localhost:4567/+

TODO needs a screenshot? I have one - not sure where to put it.

h3. Templates, Partials and Layouts

As mentioned before, the final HTML output is a composition of three Rails elements: +Templates+, +Partials+ and +Layouts+.
Find below a brief overview of each one of them.

h4. Templates

Action View templates can be written in several ways. If the template file has a <tt>.erb</tt> extension then it uses a mixture of ERB (included in Ruby) and HTML. If the template file has a <tt>.builder</tt> extension then a fresh instance of <tt>Builder::XmlMarkup</tt> library is used.

Rails supports multiple template systems and uses a file extension to distinguish amongst them. For example, an HTML file using the ERB template system will have <tt>.html.erb</tt> as a file extension.

h5. ERB

Within an ERB template Ruby code can be included using both +<% %>+ and +<%= %>+ tags. The +<% %>+ are used to execute Ruby code that does not return anything, such as conditions, loops or blocks, and the +<%= %>+ tags are used when you want output.

Consider the following loop for names:

<erb>
<b>Names of all the people</b>
<% @people.each do |person| %>
  Name: <%= person.name %><br/>
<% end %>
</erb>

The loop is setup in regular embedding tags +<% %>+ and the name is written using the output embedding tag +<%= %>+. Note that this is not just a usage suggestion, for Regular output functions like print or puts won't work with ERB templates. So this would be wrong:

<erb>
<%# WRONG %>
Hi, Mr. <% puts "Frodo" %>
</erb>

To suppress leading and trailing whitespaces, you can use +<%-+ +-%>+ interchangeably with +<%+ and +%>+.

h5. Builder

Builder templates are a more programmatic alternative to ERB. They are especially useful for generating XML content. An XmlMarkup object named +xml+ is automatically made available to templates with a <tt>.builder</tt> extension.

Here are some basic examples:

<ruby>
xml.em("emphasized")
xml.em { xml.b("emph & bold") }
xml.a("A Link", "href"=>"http://rubyonrails.org")
xml.target("name"=>"compile", "option"=>"fast")
</ruby>

will produce

<html>
<em>emphasized</em>
<em><b>emph &amp; bold</b></em>
<a href="http://rubyonrails.org">A link</a>
<target option="fast" name="compile" />
</html>

Any method with a block will be treated as an XML markup tag with nested markup in the block. For example, the following:

<ruby>
xml.div {
  xml.h1(@person.name)
  xml.p(@person.bio)
}
</ruby>

would produce something like:

<html>
<div>
  <h1>David Heinemeier Hansson</h1>
  <p>A product of Danish Design during the Winter of '79...</p>
</div>
</html>

A full-length RSS example actually used on Basecamp:

<ruby>
xml.rss("version" => "2.0", "xmlns:dc" => "http://purl.org/dc/elements/1.1/") do
  xml.channel do
    xml.title(@feed_title)
    xml.link(@url)
    xml.description "Basecamp: Recent items"
    xml.language "en-us"
    xml.ttl "40"

    for item in @recent_items
      xml.item do
        xml.title(item_title(item))
        xml.description(item_description(item)) if item_description(item)
        xml.pubDate(item_pubDate(item))
        xml.guid(@person.firm.account.url + @recent_items.url(item))
        xml.link(@person.firm.account.url + @recent_items.url(item))
        xml.tag!("dc:creator", item.author_name) if item_has_creator?(item)
      end
    end
  end
end
</ruby>

h5. Template Caching

By default, Rails will compile each template to a method in order to render it. When you alter a template, Rails will check the file's modification time and recompile it in development mode.

h4. Partials

Partial templates – usually just called "partials" – are another device for breaking the rendering process into more manageable chunks. With a partial, you can move the code for rendering a particular piece of a response to its own file.

h5. Naming Partials

To render a partial as part of a view, you use the +render+ method within the view:

<ruby>
<%= render "menu" %>
</ruby>

This will render a file named +_menu.html.erb+ at that point within the view is being rendered. Note the leading underscore character: partials are named with a leading underscore to distinguish them from regular views, even though they are referred to without the underscore. This holds true even when you're pulling in a partial from another folder:

<ruby>
<%= render "shared/menu" %>
</ruby>

That code will pull in the partial from +app/views/shared/_menu.html.erb+.

h5. Using Partials to simplify Views

One way to use partials is to treat them as the equivalent of subroutines: as a way to move details out of a view so that you can grasp what's going on more easily. For example, you might have a view that looked like this:

<erb>
<%= render "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
<% @products.each do |product| %>
  <%= render :partial => "product", :locals => { :product => product } %>
<% end %>

<%= render "shared/footer" %>
</erb>

Here, the +_ad_banner.html.erb+ and +_footer.html.erb+ partials could contain content that is shared among many pages in your application. You don't need to see the details of these sections when you're concentrating on a particular page.

h5. The :as and :object options

By default <tt>ActionView::Partials::PartialRenderer</tt> has its object in a local variable with the same name as the template. So, given

<erb>
<%= render :partial => "product" %>
</erb>

within product we'll get <tt>@product</tt> in the local variable +product+, as if we had written:

<erb>
<%= render :partial => "product", :locals => { :product  => @product } %>
</erb>

With the <tt>:as</tt> option we can specify a different name for said local variable. For example, if we wanted it to be +item+ instead of product+ we'd do:

<erb>
<%= render :partial => "product", :as => 'item' %>
</erb>

The <tt>:object</tt> option can be used to directly specify which object is rendered into the partial; useful when the template's object is elsewhere, in a different ivar or in a local variable for instance.

For example, instead of:

<erb>
<%= render :partial => "product", :locals => { :product  => @item } %>
</erb>

you'd do:

<erb>
<%= render :partial => "product", :object => @item %>
</erb>

The <tt>:object</tt> and <tt>:as</tt> options can be used together.

h5. Rendering Collections

The example of partial use describes a familiar pattern where a template needs to iterate over an array and render a sub template for each of the elements. This pattern has been implemented as a single method that accepts an array and renders a partial by the same name as the elements contained within.
So the three-lined example for rendering all the products can be rewritten with a single line:

<erb>
<%= render :partial => "product", :collection => @products %>
</erb>

When a partial is called with a pluralized collection, then the individual instances of the partial have access to the member of the collection being rendered via a variable named after the partial. In this case, the partial is +_product+ , and within the +_product+ partial, you can refer to +product+ to get the instance that is being rendered.

You can use a shorthand syntax for rendering collections. Assuming @products is a collection of +Product+ instances, you can simply write the following to produce the same result:

<erb>
<%= render @products %>
</erb>

Rails determines the name of the partial to use by looking at the model name in the collection. In fact, you can even create a heterogeneous collection and render it this way, and Rails will choose the proper partial for each member of the collection.

h5. Spacer Templates

You can also specify a second partial to be rendered between instances of the main partial by using the +:spacer_template+ option:

<erb>
<%= render @products, :spacer_template => "product_ruler" %>
</erb>

Rails will render the +_product_ruler+ partial (with no data passed in to it) between each pair of +_product+ partials.

h4. Layouts

TODO...

h3. Using Templates, Partials and Layouts in "The Rails Way"

TODO...

h3. Partial Layouts

Partials can have their own layouts applied to them. These layouts are different than the ones that are specified globally for the entire action, but they work in a similar fashion.

Let's say we're displaying a post on a page where it should be wrapped in a +div+ for display purposes. First, we'll create a new +Post+:

<ruby>
Post.create(:body => 'Partial Layouts are cool!')
</ruby>

In the +show+ template, we'll render the +post+ partial wrapped in the +box+ layout:

*posts/show.html.erb*

<ruby>
<%= render :partial => 'post', :layout => 'box', :locals => {:post => @post} %>
</ruby>

The +box+ layout simply wraps the +post+ partial in a +div+:

*posts/_box.html.erb*

<ruby>
<div class='box'>
  <%= yield %>
</div>
</ruby>

The +post+ partial wraps the post's +body+ in a +div+ with the +id+ of the post using the +div_for+ helper:

*posts/_post.html.erb*

<ruby>
<%= div_for(post) do %>
  <p><%= post.body %></p>
<% end %>
</ruby>

This example would output the following:

<html>
<div class='box'>
  <div id='post_1'>
    <p>Partial Layouts are cool!</p>
  </div>
</div>
</html>

Note that the partial layout has access to the local +post+ variable that was passed into the +render+ call. However, unlike application-wide layouts, partial layouts still have the underscore prefix.

You can also render a block of code within a partial layout instead of calling +yield+. For example, if we didn't have the +post+ partial, we could do this instead:

*posts/show.html.erb*

<ruby>
<% render(:layout => 'box', :locals => {:post => @post}) do %>
  <%= div_for(post) do %>
    <p><%= post.body %></p>
  <% end %>
<% end %>
</ruby>

If we're using the same +box+ partial from above, his would produce the same output as the previous example.

h3. View Paths

TODO...

h3. Overview of all the helpers provided by Action View

The following is only a brief overview summary of the helpers available in Action View. It's recommended that you review the API Documentation, which covers all of the helpers in more detail, but this should serve as a good starting point.

h4. ActiveRecordHelper

The Active Record Helper makes it easier to create forms for records kept in instance variables. You may also want to review the "Rails Form helpers guide":form_helpers.html.

h5. error_message_on

Returns a string containing the error message attached to the method on the object if one exists.

<ruby>
error_message_on "post", "title"
</ruby>

h5. error_messages_for

Returns a string with a DIV containing all of the error messages for the objects located as instance variables by the names given.

<ruby>
error_messages_for "post"
</ruby>

h5. form

Returns a form with inputs for all attributes of the specified Active Record object. For example, let's say we have a +@post+ with attributes named +title+ of type +String+ and +body+ of type +Text+. Calling +form+ would produce a form to creating a new post with inputs for those attributes.

<ruby>
form("post")
</ruby>

<html>
<form action='/posts/create' method='post'>
  <p>
    <label for="post_title">Title</label><br />
    <input id="post_title" name="post[title]" size="30" type="text" value="Hello World" />
  </p>
  <p>
    <label for="post_body">Body</label><br />
    <textarea cols="40" id="post_body" name="post[body]" rows="20"></textarea>
  </p>
  <input name="commit" type="submit" value="Create" />
</form>
</html>

Typically, +form_for+ is used instead of +form+ because it doesn't automatically include all of the model's attributes.

h5. input

Returns a default input tag for the type of object returned by the method.

For example, if +@post+ has an attribute +title+ mapped to a +String+ column that holds "Hello World":

<ruby>
input("post", "title") # =>
  <input id="post_title" name="post[title]" size="30" type="text" value="Hello World" />
</ruby>

h4. RecordTagHelper

This module provides methods for generating a container tag, such as a +<div>+, for your record. This is the recommended way of creating a container for render your Active Record object, as it adds an appropriate class and id attributes to that container. You can then refer to those containers easily by following the convention, instead of having to think about which class or id attribute you should use.

h5. content_tag_for

Renders a container tag that relates to your Active Record Object.

For example, given +@post+ is the object of +Post+ class, you can do:

<ruby>
<%= content_tag_for(:tr, @post) do %>
  <td><%= @post.title %></td>
<% end %>
</ruby>

This will generate this HTML output:

<html>
<tr id="post_1234" class="post">
  <td>Hello World!</td>
</tr>
</html>

You can also supply HTML attributes as an additional option hash. For example:

<ruby>
<%= content_tag_for(:tr, @post, :class => "frontpage") do %>
  <td><%= @post.title %></td>
<% end %>
</ruby>

Will generate this HTML output:

<html>
<tr id="post_1234" class="post frontpage">
  <td>Hello World!</td>
</tr>
</html>

You can pass a collection of Active Record objects. This method will loop through your objects and create a container for each of them. For example, given +@posts+ is an array of two +Post+ objects:

<ruby>
<%= content_tag_for(:tr, @posts) do |post| %>
  <td><%= post.title %></td>
<% end %>
</ruby>

Will generate this HTML output:

<html>
<tr id="post_1234" class="post">
  <td>Hello World!</td>
</tr>
<tr id="post_1235" class="post">
  <td>Ruby on Rails Rocks!</td>
</tr>
</html>

h5. div_for

This is actually a convenient method which calls +content_tag_for+ internally with +:div+ as the tag name. You can pass either an Active Record object or a collection of objects. For example:

<ruby>
<%= div_for(@post, :class => "frontpage") do %>
  <td><%= @post.title %></td>
<% end %>
</ruby>

Will generate this HTML output:

<html>
<div id="post_1234" class="post frontpage">
  <td>Hello World!</td>
</div>
</html>

h4. AssetTagHelper

This module provides methods for generating HTML that links views to assets such as images, JavaScript files, stylesheets, and feeds.

By default, Rails links to these assets on the current host in the public folder, but you can direct Rails to link to assets from a dedicated assets server by setting +ActionController::Base.asset_host+ in the application configuration, typically in +config/environments/production.rb+. For example, let's say your asset host is +assets.example.com+:

<ruby>
ActionController::Base.asset_host = "assets.example.com"
image_tag("rails.png") # => <img src="http://assets.example.com/images/rails.png" alt="Rails" />
</ruby>

h5. register_javascript_expansion

Register one or more JavaScript files to be included when symbol is passed to javascript_include_tag. This method is typically intended to be called from plugin initialization to register JavaScript files that the plugin installed in +public/javascripts+.

<ruby>
ActionView::Helpers::AssetTagHelper.register_javascript_expansion :monkey => ["head", "body", "tail"]

javascript_include_tag :monkey # =>
  <script type="text/javascript" src="/javascripts/head.js"></script>
  <script type="text/javascript" src="/javascripts/body.js"></script>
  <script type="text/javascript" src="/javascripts/tail.js"></script>
</ruby>

h5. register_stylesheet_expansion

Register one or more stylesheet files to be included when symbol is passed to +stylesheet_link_tag+. This method is typically intended to be called from plugin initialization to register stylesheet files that the plugin installed in +public/stylesheets+.

<ruby>
ActionView::Helpers::AssetTagHelper.register_stylesheet_expansion :monkey => ["head", "body", "tail"]

stylesheet_link_tag :monkey # =>
  <link href="/stylesheets/head.css" media="screen" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/body.css" media="screen" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/tail.css" media="screen" rel="stylesheet" type="text/css" />
</ruby>

h5. auto_discovery_link_tag

Returns a link tag that browsers and news readers can use to auto-detect an RSS or ATOM feed.

<ruby>
auto_discovery_link_tag(:rss, "http://www.example.com/feed.rss", {:title => "RSS Feed"}) # =>
  <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="http://www.example.com/feed" />
</ruby>

h5. image_path

Computes the path to an image asset in the +public/images+ directory. Full paths from the document root will be passed through. Used internally by +image_tag+ to build the image path.

<ruby>
image_path("edit.png") # => /images/edit.png
</ruby>

h5. image_tag

Returns an html image tag for the source. The source can be a full path or a file that exists in your +public/images+ directory.

<ruby>
image_tag("icon.png") # => <img src="/images/icon.png" alt="Icon" />
</ruby>

h5. javascript_include_tag

Returns an html script tag for each of the sources provided. You can pass in the filename (+.js+ extension is optional) of JavaScript files that exist in your +public/javascripts+ directory for inclusion into the current page or you can pass the full path relative to your document root.

<ruby>
javascript_include_tag "common" # =>
  <script type="text/javascript" src="/javascripts/common.js"></script>
</ruby>

If the application does not use the asset pipeline, to include the jQuery JavaScript library in your application, pass +:defaults+ as the source. When using +:defaults+, if an +application.js+ file exists in your +public/javascripts+ directory, it will be included as well.

<ruby>
javascript_include_tag :defaults
</ruby>

You can also include all JavaScript files in the +public/javascripts+ directory using +:all+ as the source.

<ruby>
javascript_include_tag :all
</ruby>

You can also cache multiple JavaScript files into one file, which requires less HTTP connections to download and can better be compressed by gzip (leading to faster transfers). Caching will only happen if +ActionController::Base.perform_caching+ is set to true (which is the case by default for the Rails production environment, but not for the development environment).

<ruby>
javascript_include_tag :all, :cache => true # =>
  <script type="text/javascript" src="/javascripts/all.js"></script>
</ruby>

h5. javascript_path

Computes the path to a JavaScript asset in the +public/javascripts+ directory. If the source filename has no extension, +.js+ will be appended. Full paths from the document root will be passed through. Used internally by +javascript_include_tag+ to build the script path.

<ruby>
javascript_path "common" # => /javascripts/common.js
</ruby>

h5. stylesheet_link_tag

Returns a stylesheet link tag for the sources specified as arguments. If you don't specify an extension, +.css+ will be appended automatically.

<ruby>
stylesheet_link_tag "application" # =>
  <link href="/stylesheets/application.css" media="screen" rel="stylesheet" type="text/css" />
</ruby>

You can also include all styles in the stylesheet directory using :all as the source:

<ruby>
stylesheet_link_tag :all
</ruby>

You can also cache multiple stylesheets into one file, which requires less HTTP connections and can better be compressed by gzip (leading to faster transfers). Caching will only happen if ActionController::Base.perform_caching is set to true (which is the case by default for the Rails production environment, but not for the development environment).

<ruby>
stylesheet_link_tag :all, :cache => true
  <link href="/stylesheets/all.css"  media="screen" rel="stylesheet" type="text/css" />
</ruby>

h5. stylesheet_path

Computes the path to a stylesheet asset in the +public/stylesheets+ directory. If the source filename has no extension, .css will be appended. Full paths from the document root will be passed through. Used internally by stylesheet_link_tag to build the stylesheet path.

<ruby>
stylesheet_path "application" # => /stylesheets/application.css
</ruby>

h4. AtomFeedHelper

h5. atom_feed

This helper makes building an ATOM feed easy. Here's a full usage example:

*config/routes.rb*

<ruby>
resources :posts
</ruby>

*app/controllers/posts_controller.rb*

<ruby>
def index
  @posts = Post.all

  respond_to do |format|
    format.html
    format.atom
  end
end
</ruby>

*app/views/posts/index.atom.builder*

<ruby>
atom_feed do |feed|
  feed.title("Posts Index")
  feed.updated((@posts.first.created_at))

  @posts.each do |post|
    feed.entry(post) do |entry|
      entry.title(post.title)
      entry.content(post.body, :type => 'html')

      entry.author do |author|
        author.name(post.author_name)
      end
    end
  end
end
</ruby>

h4. BenchmarkHelper

h5. benchmark

Allows you to measure the execution time of a block in a template and records the result to the log. Wrap this block around expensive operations or possible bottlenecks to get a time reading for the operation.

<ruby>
<% benchmark "Process data files" do %>
  <%= expensive_files_operation %>
<% end %>
</ruby>

This would add something like "Process data files (0.34523)" to the log, which you can then use to compare timings when optimizing your code.

h4. CacheHelper

h5. cache

A method for caching fragments of a view rather than an entire action or page. This technique is useful caching pieces like menus, lists of news topics, static HTML fragments, and so on. This method takes a block that contains the content you wish to cache. See +ActionController::Caching::Fragments+ for more information.

<ruby>
<% cache do %>
  <%= render "shared/footer" %>
<% end %>
</ruby>

h4. CaptureHelper

h5. capture

The +capture+ method allows you to extract part of a template into a variable. You can then use this variable anywhere in your templates or layout.

<ruby>
<% @greeting = capture do %>
  <p>Welcome! The date and time is <%= Time.now %></p>
<% end %>
</ruby>

The captured variable can then be used anywhere else.

<ruby>
<html>
  <head>
    <title>Welcome!</title>
  </head>
  <body>
    <%= @greeting %>
  </body>
</html>
</ruby>

h5. content_for

Calling +content_for+ stores a block of markup in an identifier for later use. You can make subsequent calls to the stored content in other templates or the layout by passing the identifier as an argument to +yield+.

For example, let's say we have a standard application layout, but also a special page that requires certain Javascript that the rest of the site doesn't need. We can use +content_for+ to include this Javascript on our special page without fattening up the rest of the site.

*app/views/layouts/application.html.erb*

<ruby>
<html>
  <head>
    <title>Welcome!</title>
    <%= yield :special_script %>
  </head>
  <body>
    <p>Welcome! The date and time is <%= Time.now %></p>
  </body>
</html>
</ruby>

*app/views/posts/special.html.erb*

<ruby>
<p>This is a special page.</p>

<% content_for :special_script do %>
  <script type="text/javascript">alert('Hello!')</script>
<% end %>
</ruby>

h4. DateHelper

h5. date_select

Returns a set of select tags (one for year, month, and day) pre-selected for accessing a specified date-based attribute.

<ruby>
date_select("post", "published_on")
</ruby>

h5. datetime_select

Returns a set of select tags (one for year, month, day, hour, and minute) pre-selected for accessing a specified datetime-based attribute.

<ruby>
datetime_select("post", "published_on")
</ruby>

h5. distance_of_time_in_words

Reports the approximate distance in time between two Time or Date objects or integers as seconds. Set +include_seconds+ to true if you want more detailed approximations.

<ruby>
distance_of_time_in_words(Time.now, Time.now + 15.seconds)        # => less than a minute
distance_of_time_in_words(Time.now, Time.now + 15.seconds, true)  # => less than 20 seconds
</ruby>

h5. select_date

Returns a set of html select-tags (one for year, month, and day) pre-selected with the +date+ provided.

<ruby>
# Generates a date select that defaults to the date provided (six days after today)
select_date(Time.today + 6.days)

# Generates a date select that defaults to today (no specified date)
select_date()
</ruby>

h5. select_datetime

Returns a set of html select-tags (one for year, month, day, hour, and minute) pre-selected with the +datetime+ provided.

<ruby>
# Generates a datetime select that defaults to the datetime provided (four days after today)
select_datetime(Time.now + 4.days)

# Generates a datetime select that defaults to today (no specified datetime)
select_datetime()
</ruby>

h5. select_day

Returns a select tag with options for each of the days 1 through 31 with the current day selected.

<ruby>
# Generates a select field for days that defaults to the day for the date provided
select_day(Time.today + 2.days)

# Generates a select field for days that defaults to the number given
select_day(5)
</ruby>

h5. select_hour

Returns a select tag with options for each of the hours 0 through 23 with the current hour selected.

<ruby>
# Generates a select field for minutes that defaults to the minutes for the time provided
select_minute(Time.now + 6.hours)
</ruby>

h5. select_minute

Returns a select tag with options for each of the minutes 0 through 59 with the current minute selected.

<ruby>
# Generates a select field for minutes that defaults to the minutes for the time provided.
select_minute(Time.now + 6.hours)
</ruby>

h5. select_month

Returns a select tag with options for each of the months January through December with the current month selected.

<ruby>
# Generates a select field for months that defaults to the current month
select_month(Date.today)
</ruby>

h5. select_second

Returns a select tag with options for each of the seconds 0 through 59 with the current second selected.

<ruby>
# Generates a select field for seconds that defaults to the seconds for the time provided
select_second(Time.now + 16.minutes)
</ruby>

h5. select_time

Returns a set of html select-tags (one for hour and minute).

<ruby>
# Generates a time select that defaults to the time provided
select_time(Time.now)
</ruby>

h5. select_year

Returns a select tag with options for each of the five years on each side of the current, which is selected. The five year radius can be changed using the +:start_year+ and +:end_year+ keys in the +options+.

<ruby>
# Generates a select field for five years on either side of Date.today that defaults to the current year
select_year(Date.today)

# Generates a select field from 1900 to 2009 that defaults to the current year
select_year(Date.today, :start_year => 1900, :end_year => 2009)
</ruby>

h5. time_ago_in_words

Like +distance_of_time_in_words+, but where +to_time+ is fixed to +Time.now+.

<ruby>
time_ago_in_words(3.minutes.from_now)       # => 3 minutes
</ruby>

h5. time_select

Returns a set of select tags (one for hour, minute and optionally second) pre-selected for accessing a specified time-based attribute. The selects are prepared for multi-parameter assignment to an Active Record object.

<ruby>
# Creates a time select tag that, when POSTed, will be stored in the order variable in the submitted attribute
time_select("order", "submitted")
</ruby>

h4. DebugHelper

Returns a +pre+ tag that has object dumped by YAML. This creates a very readable way to inspect an object.

<ruby>
my_hash = {'first' => 1, 'second' => 'two', 'third' => [1,2,3]}
debug(my_hash)
</ruby>

<html>
<pre class='debug_dump'>---
first: 1
second: two
third:
- 1
- 2
- 3
</pre>
</html>

h4. FormHelper

Form helpers are designed to make working with models much easier compared to using just standard HTML elements by providing a set of methods for creating forms based on your models. This helper generates the HTML for forms, providing a method for each sort of input (e.g., text, password, select, and so on). When the form is submitted (i.e., when the user hits the submit button or form.submit is called via JavaScript), the form inputs will be bundled into the params object and passed back to the controller.

There are two types of form helpers: those that specifically work with model attributes and those that don't. This helper deals with those that work with model attributes; to see an example of form helpers that don't work with model attributes, check the ActionView::Helpers::FormTagHelper documentation.

The core method of this helper, form_for, gives you the ability to create a form for a model instance; for example, let's say that you have a model Person and want to create a new instance of it:

<ruby>
# Note: a @person variable will have been created in the controller (e.g. @person = Person.new)
<%= form_for @person, :url => { :action => "create" } do |f| %>
  <%= f.text_field :first_name %>
  <%= f.text_field :last_name %>
  <%= submit_tag 'Create' %>
<% end %>
</ruby>

The HTML generated for this would be:

<html>
<form action="/persons/create" method="post">
  <input id="person_first_name" name="person[first_name]" size="30" type="text" />
  <input id="person_last_name" name="person[last_name]" size="30" type="text" />
  <input name="commit" type="submit" value="Create" />
</form>
</html>

The params object created when this form is submitted would look like:

<ruby>
{"action"=>"create", "controller"=>"persons", "person"=>{"first_name"=>"William", "last_name"=>"Smith"}}
</ruby>

The params hash has a nested person value, which can therefore be accessed with params[:person] in the controller.

h5. check_box

Returns a checkbox tag tailored for accessing a specified attribute.

<ruby>
# Let's say that @post.validated? is 1:
check_box("post", "validated")
# => <input type="checkbox" id="post_validated" name="post[validated]" value="1" />
#    <input name="post[validated]" type="hidden" value="0" />
</ruby>

h5. fields_for

Creates a scope around a specific model object like form_for, but doesn't create the form tags themselves. This makes fields_for suitable for specifying additional model objects in the same form:

<ruby>
<%= form_for @person, :url => { :action => "update" } do |person_form| %>
  First name: <%= person_form.text_field :first_name %>
  Last name : <%= person_form.text_field :last_name %>

  <%= fields_for @person.permission do |permission_fields| %>
    Admin?  : <%= permission_fields.check_box :admin %>
  <% end %>
<% end %>
</ruby>

h5. file_field

Returns a file upload input tag tailored for accessing a specified attribute.

<ruby>
file_field(:user, :avatar)
# => <input type="file" id="user_avatar" name="user[avatar]" />
</ruby>

h5. form_for

Creates a form and a scope around a specific model object that is used as a base for questioning about values for the fields.

<ruby>
<%= form_for @post do |f| %>
  <%= f.label :title, 'Title' %>:
  <%= f.text_field :title %><br />
  <%= f.label :body, 'Body' %>:
  <%= f.text_area :body %><br />
<% end %>
</ruby>

h5. hidden_field

Returns a hidden input tag tailored for accessing a specified attribute.

<ruby>
hidden_field(:user, :token)
# => <input type="hidden" id="user_token" name="user[token]" value="#{@user.token}" />
</ruby>

h5. label

Returns a label tag tailored for labelling an input field for a specified attribute.

<ruby>
label(:post, :title)
# => <label for="post_title">Title</label>
</ruby>

h5. password_field

Returns an input tag of the "password" type tailored for accessing a specified attribute.

<ruby>
password_field(:login, :pass)
# => <input type="text" id="login_pass" name="login[pass]" value="#{@login.pass}" />
</ruby>

h5. radio_button

Returns a radio button tag for accessing a specified attribute.

<ruby>
# Let's say that @post.category returns "rails":
radio_button("post", "category", "rails")
radio_button("post", "category", "java")
# => <input type="radio" id="post_category_rails" name="post[category]" value="rails" checked="checked" />
#    <input type="radio" id="post_category_java" name="post[category]" value="java" />
</ruby>

h5. text_area

Returns a textarea opening and closing tag set tailored for accessing a specified attribute.

<ruby>
text_area(:comment, :text, :size => "20x30")
# => <textarea cols="20" rows="30" id="comment_text" name="comment[text]">
#      #{@comment.text}
#    </textarea>
</ruby>

h5. text_field

Returns an input tag of the "text" type tailored for accessing a specified attribute.

<ruby>
text_field(:post, :title)
# => <input type="text" id="post_title" name="post[title]" value="#{@post.title}" />
</ruby>

h4. FormOptionsHelper

Provides a number of methods for turning different kinds of containers into a set of option tags.

h5. collection_select

Returns +select+ and +option+ tags for the collection of existing return values of +method+ for +object+'s class.

Example object structure for use with this method:

<ruby>
class Post < ActiveRecord::Base
  belongs_to :author
end

class Author < ActiveRecord::Base
  has_many :posts
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
</ruby>

Sample usage (selecting the associated Author for an instance of Post, +@post+):

<ruby>
collection_select(:post, :author_id, Author.all, :id, :name_with_initial, {:prompt => true})
</ruby>

If <tt>@post.author_id</tt> is 1, this would return:

<html>
<select name="post[author_id]">
  <option value="">Please select</option>
  <option value="1" selected="selected">D. Heinemeier Hansson</option>
  <option value="2">D. Thomas</option>
  <option value="3">M. Clark</option>
</select>
</html>

h5. country_options_for_select

Returns a string of option tags for pretty much any country in the world.

h5. country_select

Return select and option tags for the given object and method, using country_options_for_select to generate the list of option tags.

h5. option_groups_from_collection_for_select

Returns a string of +option+ tags, like +options_from_collection_for_select+, but groups them by +optgroup+ tags based on the object relationships of the arguments.

Example object structure for use with this method:

<ruby>
class Continent < ActiveRecord::Base
  has_many :countries
  # attribs: id, name
end

class Country < ActiveRecord::Base
  belongs_to :continent
  # attribs: id, name, continent_id
end
</ruby>

Sample usage:

<ruby>
option_groups_from_collection_for_select(@continents, :countries, :name, :id, :name, 3)
</ruby>

Possible output:

<html>
<optgroup label="Africa">
  <option value="1">Egypt</option>
  <option value="4">Rwanda</option>
  ...
</optgroup>
<optgroup label="Asia">
  <option value="3" selected="selected">China</option>
  <option value="12">India</option>
  <option value="5">Japan</option>
  ...
</optgroup>
</html>

Note: Only the +optgroup+ and +option+ tags are returned, so you still have to wrap the output in an appropriate +select+ tag.

h5. options_for_select

Accepts a container (hash, array, enumerable, your type) and returns a string of option tags.

<ruby>
options_for_select([ "VISA", "MasterCard" ])
# => <option>VISA</option> <option>MasterCard</option>
</ruby>

Note: Only the +option+ tags are returned, you have to wrap this call in a regular HTML +select+ tag.

h5. options_from_collection_for_select

Returns a string of option tags that have been compiled by iterating over the +collection+ and assigning the result of a call to the +value_method+ as the option value and the +text_method+ as the option text.

<ruby>
# options_from_collection_for_select(collection, value_method, text_method, selected = nil)
</ruby>

For example, imagine a loop iterating over each person in @project.people to generate an input tag:

<ruby>
options_from_collection_for_select(@project.people, "id", "name")
# => <option value="#{person.id}">#{person.name}</option>
</ruby>

Note: Only the +option+ tags are returned, you have to wrap this call in a regular HTML +select+ tag.

h5. select

Create a select tag and a series of contained option tags for the provided object and method.

Example:

<ruby>
select("post", "person_id", Person.all.collect {|p| [ p.name, p.id ] }, { :include_blank => true })
</ruby>

If <tt>@post.person_id</tt> is 1, this would become:

<html>
<select name="post[person_id]">
  <option value=""></option>
  <option value="1" selected="selected">David</option>
  <option value="2">Sam</option>
  <option value="3">Tobias</option>
</select>
</html>

h5. time_zone_options_for_select

Returns a string of option tags for pretty much any time zone in the world.

h5. time_zone_select

Return select and option tags for the given object and method, using +time_zone_options_for_select+ to generate the list of option tags.

<ruby>
time_zone_select( "user", "time_zone")
</ruby>

h4. FormTagHelper

Provides a number of methods for creating form tags that doesn't rely on an Active Record object assigned to the template like FormHelper does. Instead, you provide the names and values manually.

h5. check_box_tag

Creates a check box form input tag.

<ruby>
check_box_tag 'accept'
# => <input id="accept" name="accept" type="checkbox" value="1" />
</ruby>

h5. field_set_tag

Creates a field set for grouping HTML form elements.

<ruby>
<%= field_set_tag do %>
  <p><%= text_field_tag 'name' %></p>
<% end %>
# => <fieldset><p><input id="name" name="name" type="text" /></p></fieldset>
</ruby>

h5. file_field_tag

Creates a file upload field.

Prior to Rails 3.1, if you are using file uploads, then you will need to set the multipart option for the form tag. Rails 3.1+ does this automatically.

<ruby>
<%= form_tag { :action => "post" }, { :multipart => true } do %>
  <label for="file">File to Upload</label> <%= file_field_tag "file" %>
  <%= submit_tag %>
<% end %>
</ruby>

Example output:

<ruby>
file_field_tag 'attachment'
# => <input id="attachment" name="attachment" type="file" />
</ruby>

h5. form_tag

Starts a form tag that points the action to an url configured with +url_for_options+ just like +ActionController::Base#url_for+.

<ruby>
<%= form_tag '/posts' do %>
  <div><%= submit_tag 'Save' %></div>
<% end %>
# => <form action="/posts" method="post"><div><input type="submit" name="submit" value="Save" /></div></form>
</ruby>

h5. hidden_field_tag

Creates a hidden form input field used to transmit data that would be lost due to HTTP's statelessness or data that should be hidden from the user.

<ruby>
hidden_field_tag 'token', 'VUBJKB23UIVI1UU1VOBVI@'
# => <input id="token" name="token" type="hidden" value="VUBJKB23UIVI1UU1VOBVI@" />
</ruby>

h5. image_submit_tag

Displays an image which when clicked will submit the form.

<ruby>
image_submit_tag("login.png")
# => <input src="/images/login.png" type="image" />
</ruby>

h5. label_tag

Creates a label field.

<ruby>
label_tag 'name'
# => <label for="name">Name</label>
</ruby>

h5. password_field_tag

Creates a password field, a masked text field that will hide the users input behind a mask character.

<ruby>
password_field_tag 'pass'
# => <input id="pass" name="pass" type="password" />
</ruby>

h5. radio_button_tag

Creates a radio button; use groups of radio buttons named the same to allow users to select from a group of options.

<ruby>
radio_button_tag 'gender', 'male'
# => <input id="gender_male" name="gender" type="radio" value="male" />
</ruby>

h5. select_tag

Creates a dropdown selection box.

<ruby>
select_tag "people", "<option>David</option>"
# => <select id="people" name="people"><option>David</option></select>
</ruby>

h5. submit_tag

Creates a submit button with the text provided as the caption.

<ruby>
submit_tag "Publish this post"
# => <input name="commit" type="submit" value="Publish this post" />
</ruby>

h5. text_area_tag

Creates a text input area; use a textarea for longer text inputs such as blog posts or descriptions.

<ruby>
text_area_tag 'post'
# => <textarea id="post" name="post"></textarea>
</ruby>

h5. text_field_tag

Creates a standard text field; use these text fields to input smaller chunks of text like a username or a search query.

<ruby>
text_field_tag 'name'
# => <input id="name" name="name" type="text" />
</ruby>

h4. JavaScriptHelper

Provides functionality for working with JavaScript in your views.

h5. button_to_function

Returns a button that'll trigger a JavaScript function using the onclick handler. Examples:

<ruby>
button_to_function "Greeting", "alert('Hello world!')"
button_to_function "Delete", "if (confirm('Really?')) do_delete()"
button_to_function "Details" do |page|
  page[:details].visual_effect :toggle_slide
end
</ruby>

h5. define_javascript_functions

Includes the Action Pack JavaScript libraries inside a single +script+ tag.

h5. escape_javascript

Escape carrier returns and single and double quotes for JavaScript segments.

h5. javascript_tag

Returns a JavaScript tag wrapping the provided code.

<ruby>
javascript_tag "alert('All is good')"
</ruby>

<html>
<script type="text/javascript">
//<![CDATA[
alert('All is good')
//]]>
</script>
</html>

h5. link_to_function

Returns a link that will trigger a JavaScript function using the onclick handler and return false after the fact.

<ruby>
link_to_function "Greeting", "alert('Hello world!')"
# => <a onclick="alert('Hello world!'); return false;" href="#">Greeting</a>
</ruby>

h4. NumberHelper

Provides methods for converting numbers into formatted strings. Methods are provided for phone numbers, currency, percentage, precision, positional notation, and file size.

h5. number_to_currency

Formats a number into a currency string (e.g., $13.65).

<ruby>
number_to_currency(1234567890.50) # => $1,234,567,890.50
</ruby>

h5. number_to_human_size

Formats the bytes in size into a more understandable representation; useful for reporting file sizes to users.

<ruby>
number_to_human_size(1234)          # => 1.2 KB
number_to_human_size(1234567)       # => 1.2 MB
</ruby>

h5. number_to_percentage

Formats a number as a percentage string.

<ruby>
number_to_percentage(100, :precision => 0)        # => 100%
</ruby>

h5. number_to_phone

Formats a number into a US phone number.

<ruby>
number_to_phone(1235551234) # => 123-555-1234
</ruby>

h5. number_with_delimiter

Formats a number with grouped thousands using a delimiter.

<ruby>
number_with_delimiter(12345678) # => 12,345,678
</ruby>

h5. number_with_precision

Formats a number with the specified level of +precision+, which defaults to 3.

<ruby>
number_with_precision(111.2345)     # => 111.235
number_with_precision(111.2345, 2)  # => 111.23
</ruby>

h3. Localized Views

Action View has the ability render different templates depending on the current locale.

For example, suppose you have a Posts controller with a show action. By default, calling this action will render +app/views/posts/show.html.erb+. But if you set +I18n.locale = :de+, then +app/views/posts/show.de.html.erb+ will be rendered instead. If the localized template isn't present, the undecorated version will be used. This means you're not required to provide localized views for all cases, but they will be preferred and used if available.

You can use the same technique to localize the rescue files in your public directory. For example, setting +I18n.locale = :de+ and creating +public/500.de.html+ and +public/404.de.html+ would allow you to have localized rescue pages.

Since Rails doesn't restrict the symbols that you use to set I18n.locale, you can leverage this system to display different content depending on anything you like. For example, suppose you have some "expert" users that should see different pages from "normal" users. You could add the following to +app/controllers/application.rb+:

<ruby>
before_filter :set_expert_locale

def set_expert_locale
  I18n.locale = :expert if current_user.expert?
end
</ruby>

Then you could create special views like +app/views/posts/show.expert.html.erb+ that would only be displayed to expert users.

You can read more about the Rails Internationalization (I18n) API "here":i18n.html.
